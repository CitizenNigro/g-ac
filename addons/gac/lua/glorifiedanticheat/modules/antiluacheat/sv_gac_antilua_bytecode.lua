local
a={a='StringInBuffer',b='linedefined'}local
b=bit.band
local
c=bit.rshift
local
d=jit.util.funcbc
local
e=table.concat
local
f=string.char
local
g=isstring
local
h=tonumber
local
i=util.CRC
ByteCode={}local
j={[0x46]=0x51,[0x47]=0x51,[0x48]=0x51,[0x49]=0x49,[0x4A]=0x49,[0x4B]=0x4B,[0x4C]=0x4B,[0x4D]=0x4B,[0x4E]=0x4E,[0x4F]=0x4E,[0x50]=0x4E,[0x51]=0x51,[0x52]=0x51,[0x53]=0x51,}local
k={[0x44]=0x54,[0x42]=0x41,}function
ByteCode.FunctionToHash(l,m)local
n={}for
o=1,m.bytecodes-1
do
local
p=d(l,o)local
q=b(p,0xFF)if
j[q]then
p=j[q]end
if
k[q]then
p=p-q
p=p+k[q]end
n[#n+1]=f(b(p,0xFF),b(c(p,8),0xFF),b(c(p,16),0xFF),b(c(p,24),0xFF))end
return
h(i(e(n)))end
function
ByteCode.ByteCodeDumpToHash(l,m)if
g(l)then
l=gAC[a.a](l)end
local
n=gAC.StringOutBuffer()for
o=1,m
do
local
p=l:UInt32()local
q=b(p,0xFF)if
j[q]then
p=j[q]end
if
k[q]then
p=p-q
p=p+k[q]end
n:UInt32(p)end
return
h(i(n:GetString()))end
function
ByteCode.GetFuncInformation(l,m)m=m
or{}if
g(l)then
l=gAC[a.a](l)end
l:UInt8()l:UInt8()l:UInt8()l:UInt8()l:ULEB128()l:ULEB128()local
n=l:ULEB128()l:ULEB128()m[a.b]=l:ULEB128()local
o=l:ULEB128()m.lastlinedefined=m[a.b]+o
m.proto=ByteCode.ByteCodeDumpToHash(l,n)return
m
end
function
ByteCode.DumpToFunctionList(l)local
m=gAC[a.a](l)m:Bytes(4)m:UInt8()m:Bytes(m:ULEB128())local
n={}local
o=m:ULEB128()while
o~=0
do
local
p=m:Bytes(o)local
q=ByteCode.GetFuncInformation(p)n[#n+1]=q
o=m:ULEB128()end
return
n
end