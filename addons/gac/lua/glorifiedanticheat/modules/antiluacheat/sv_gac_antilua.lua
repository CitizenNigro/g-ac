local
_,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J={_="config",a="LuaFileCache",b="LuaSession",c="FileSourcePath",d="source",e="funclist",f="linedefined",g="lastlinedefined",h="Print",i="_VMEVENTS",j="LuaFuncSources",k="AntiLua_FunctionVerification",l="AntiLua_LuaRefresh",m="LuaExecDetected",n="AddDetection",o="AntiLua_Net_PUNISHMENT",p="AntiLua_Net_BANTIME",q="funcname",r="VerifyLuaSource",s="execidentifier",t="AddSource",u="AntiLuaAddDetection",v="gAC_LuaExecStartup"},CompileFile,SysTime,math.Round,jit.util.funcinfo,jit.attach,file.CreateDir,file.Exists,file.Time,file.Find,file.Read,file.Size,file.Write,hook.Add,isstring,tostring,istable,pairs,pcall,timer.Create,timer.Start,CompileString,IsValid,string.dump,string.lower,string.sub,string.Explode,string.gsub,table.remove,table.concat,util.Compress,util.Decompress,util.JSONToTable,util.TableToJSON,bit.rol,bit.bxor,debug.getregistry
m("gAC.Init","gAC.AntiLua",function()if!gAC[_._].AntiLua_CHECK
then
return
end
gAC[_.a]=gAC[_.a]||nil
gAC[_.b]=gAC[_.b]||{}gAC[_.c]="LUA"gAC.LuaVM=function(k)local
n=d(k)n[_.d]=A(n[_.d],"^@","")n[_.d]=gAC.dirtosvlua(n[_.d])gAC[_.a][n[_.d]]=gAC[_.a][n[_.d]]||{}local
o=gAC[_.a][n[_.d]]if
o.bytecodes
then
return
end
o[_.e]=o[_.e]||{}o[_.e][#o[_.e]+1]={linedefined=n[_.f],lastlinedefined=n[_.g],proto=ByteCode.FunctionToHash(k,n)}end
function
gAC.HashString(k)local
n=#k
for
o=1,#k
do
n=I(n,H(n,6)+k:byte(o))end
return
H(n,3)end
gAC.LuaVMID=gAC.HashString'bc'function
gAC.dirtosvlua(k)local
n=k
n=z("/",n)if
n[1]=="addons"then
B(n,1)B(n,1)B(n,1)k=C(n,"/")elseif
n[1]=="lua"then
B(n,1)k=C(n,"/")elseif
n[1]=="gamemodes"then
B(n,1)k=C(n,"/")end
return
k
end
if
gAC[_.a]==nil
then
local
function
k(n,o,r,s)if!r
then
return
end
if#n>0
then
n=n.."/"end
local
t,u=i(n.."*",o)if!t&&!u
then
gAC[_.h]("[AntiLua] Could not add "..n.." to lua information.")return
end
for
s,t
in
q(t)do
r(n..t,o)end
if
s
then
for
t,v
in
q(u)do
if
v~="."&&v~=".."then
k(n..v,o,r,s)end
end
end
end
gAC[_.h]"[AntiLua] Initializing"if!g("gac-antilua","DATA")then
f"gac-antilua"end
gAC[_.a]={}local
n=b()gAC[_.h]"[AntiLua] Building lua file cache"if
g("gac-antilua/gac-luacache.dat","DATA")then
gAC[_.h]"[AntiLua] Detected an existing lua cache file, reading..."gAC[_.a]=F(E(j("gac-antilua/gac-luacache.dat","DATA")))gAC[_.h]"[AntiLua] Checking for modifications..."else
gAC.NoLuaCache=!!1
end
local
o,r,s={},!1,gAC[_.c]local
function
t(k)if
x(y(k,-4))~=".lua"then
return
end
if
k==""then
return
end
local
n,t=h(k,s),nil
if!gAC[_.a][k]then
gAC[_.h]("[AntiLua] Excluding "..k)t=!!1
r=!!1
elseif!p(gAC[_.a][k])||n~=gAC[_.a][k].time
then
gAC[_.h]("[AntiLua] Modifying exclusion "..k)t=!!1
r=!!1
end
if
t
then
gAC[_.a][k]={time=n}local
t=a(k)if!t&&x(k)~=k
then
gAC[_.a][k]={time=n}t=a(x(k))end
if!t
then
gAC[_.h]("[AntiLua] "..k.." Compile Error")o[#o+1]=k.." - Compile Error (switch to source verification)"t=nil
gAC[_.a][k]={time=n}return
end
end
end
local
u=J()u[_.i]=u[_.i]||{}u[_.i][gAC.LuaVMID]=gAC.LuaVM
e(function()end,"")k("",s,t,!!1)u[_.i][gAC.LuaVMID]=nil
for
k,n
in
q(gAC[_.a])do
if
h(k,s)==0
then
r=!!1
gAC[_.h]("[AntiLua] Removing exclusion "..k)gAC[_.a][k]=nil
end
end
if!r
then
gAC[_.h]"[AntiLua] Everything appears up to standards"end
gAC[_.h]("[AntiLua] Finished building lua file cache, took: "..c(b()-n,2).."s")if#o>0
then
gAC[_.h](#o.." lua files have issues")for
k=1,#o
do
gAC[_.h](o[k])end
end
if
r
then
gAC[_.h]"[AntiLua] Saving lua cache..."if
gAC.NoLuaCache
then
gAC[_.h]"[AntiLua] Server will restart on InitPostEntity (needed to remove compiled files in lua)"m("InitPostEntity","gAC.AntiLua.Restart",function(k)gAC[_.h]"[AntiLua] Restarting..."RunConsoleCommand'_restart'end)end
n=b()l("gac-antilua/gac-luacache.dat",D(G(gAC[_.a])))gAC[_.h]("[AntiLua] Saving took: "..c(b()-n,2).."s")end
gAC[_.h]"[AntiLua] Waiting for core detection systems"end
end)m("gAC.IncludesLoaded","gAC.AntiLua",function()local
a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r=jit.util.funcinfo,jit.attach,file.Time,file.Write,hook.Add,isstring,istable,pairs,pcall,timer.Create,timer.Start,CompileString,IsValid,string.dump,string.gsub,util.JSONToTable,util.TableToJSON,debug.getregistry
if!gAC[_._].AntiLua_CHECK
then
return
end
gAC[_.h]"[AntiLua] Core detection system has loaded!"gAC[_.j]={["function: builtin#21"]={source="=[C]",short_src="[C]",what="C",lastlinedefined=-1,linedefined=-1},["function: builtin#20"]={source="=[C]",short_src="[C]",what="C",lastlinedefined=-1,linedefined=-1}}function
gAC.VerifyLuaSource(a,b)if!gAC[_.a][a[_.d]]&&!gAC[_.b][b][a[_.d]]then
return!1
end
return!!1
end
function
gAC.AddSource(a,b,c)if
gAC[_._][_.k]then
local
d,e=l(c,b..".AddSource",!1)if!d&&e
then
return
end
local
e=n(d)local
d=ByteCode.DumpToFunctionList(e)gAC[_.b][a][b]={funclist=d}else
gAC[_.b][a][b]=!!1
end
end
function
gAC.UpdateLuaFile(a)if!gAC[_._][_.l]then
return
end
local
b=c(a,gAC[_.c])if
b~=0
then
if
b~=gAC[_.a][a].time
then
gAC[_.h]("[AntiLua] WARNING: lua refresh occured on "..a..", switching to source verification")gAC[_.a][a]={time=b}end
else
gAC[_.h]("[AntiLua] WARNING: lua refresh occured on "..a..", switching to source verification")gAC[_.a][a]=!!1
end
end
local
c={}if!gAC[_._][_.l]then
c=nil
end
function
gAC.VerifyFunction(a,b)if!gAC[_._][_.k]then
return!!1
end
local
d=nil
if
gAC[_.b][a]&&gAC[_.b][a][b[_.d]]&&g(gAC[_.b][a][b[_.d]])&&gAC[_.b][a][b[_.d]][_.e]then
d=gAC[_.b][a][b[_.d]][_.e]elseif
gAC[_.a][b[_.d]]&&g(gAC[_.a][b[_.d]])&&gAC[_.a][b[_.d]][_.e]then
d=gAC[_.a][b[_.d]][_.e]end
if
d
then
if
c&&!c[b[_.d]]then
c[b[_.d]]=!!1
gAC.UpdateLuaFile(b[_.d])return
end
for
a=1,#d
do
local
e=d[a]if
e[_.g]~=b[_.g]then
return!1
end
if
e[_.f]~=b[_.f]then
return!1
end
if
e.proto~=b.proto
then
return!1
end
end
return!!1
end
return!!1
end
function
gAC.AntiLuaAddDetection(a,b,c,e)if
c~="Probable Execution"then
e[_.m]=!!1
gAC[_.n](e,b,gAC[_._].AntiLua_PUNISHMENT,gAC[_._].AntiLua_BANTIME)else
gAC[_.n](e,b,!1,-1)end
local
f=q(a,!!1)f="WARNING: Do not reveal this to cheaters!\nClient "..e:SteamID64().."'s reply\n"..f
f=f.."\nServer's reply\n"..b.."\n"if
c=="%unknown%"then
c="Client returned a traceback with nil or unknown type (likely a client detour attempt)"elseif
c=="Invalid Source"then
c="Client returned a traceback leading to '"..a[_.d].."' which does not exist in the lua cache"elseif
c=="Invalid Bytecode"then
c="Client returned a traceback leading to '"..a[_.d].."' which exists on the lua cache\n"c=c.."however the function information returned to it is different from the lua cache"elseif
c=="Probable Execution"then
c="Client returned a traceback leading to '"..a[_.d].."' which does not exist in the lua cache\n"c=c.."however because of the given environment information, it's unable to be confirmed."end
f=f..c
d("gac-antilua/"..e:SteamID64().."-"..os.time()..".dat",f)end
gAC.Network:AddReceiver("g-AC_LuaExec",function(a,b,d)if
d[_.m]then
return
end
local
a=d:UserID()if
b=="1"then
k("gAC.AntiLua-"..a)return
end
local
e,g=i(p,b)if!e
then
d[_.m]=!!1
gAC[_.n](d,"AntiLua network manipulation [Code 126]",gAC[_._][_.o],gAC[_._][_.p])return
end
k("gAC.AntiLua-"..a)if#g>500
then
d[_.m]=!!1
gAC[_.n](d,"AntiLua network manipulation [Code 126]",gAC[_._][_.o],gAC[_._][_.p])return
end
for
b=1,#g
do
local
e=g[b]if
e[_.q]then
if
e[_.d]&&f(e[_.d])then
if
gAC[_.r](e,a)==!1
then
if
e.func&&gAC[_.j][e.func]then
local
b=nil
for
j,l
in
h(gAC[_.j][e.func])do
if
e[j]==l
then
b=!!1
break
end
end
if
b
then
if
e[_.q]=="RunString"||e[_.q]=="RunStringEx"||e[_.q]=="CompileString"then
if
e[_.s]then
gAC[_.t](a,e[_.s],e.code)end
end
continue
end
elseif
e[_.d]=="[C]"&&e.short_src=="[C]"&&e.what=="C"then
if
e[_.q]=="RunString"||e[_.q]=="RunStringEx"||e[_.q]=="CompileString"then
if
e[_.s]then
gAC[_.t](a,e[_.s],e.code)end
end
continue
end
gAC[_.u](e,"Unauthorized lua execution (func: "..e[_.q].." | src: "..e[_.d]..") [Code 123]","Invalid Source",d)break
elseif
e[_.q]=="RunString"||e[_.q]=="RunStringEx"||e[_.q]=="CompileString"then
if
e[_.s]then
gAC[_.t](a,e[_.s],e.code)end
end
else
gAC[_.u](e,"Unauthorized lua execution [Code 123]","%unknown%",d)break
end
else
if
e[_.d]&&f(e[_.d])then
if
gAC[_.r](e,a)==!1
then
if
e[_.d]=="Startup"&&!d[_.v]&&!gAC[_._].AntiLua_IgnoreBoot
then
d[_.v]=!!1
continue
else
gAC[_.u](e,"Lua environment manipulation (src: "..e[_.d]..") [Code 124]","Invalid Source",d)break
end
elseif
gAC.VerifyFunction(e,d)==!1
then
gAC[_.u](e,"Lua environment manipulation (src: "..e[_.d]..") [Code 124]","Invalid Bytecode",d)break
end
else
gAC[_.u](e,"Lua environment manipulation [Code 124]","%unknown%",d)break
end
end
end
if
c
then
c={}end
end)e("gAC.CLFilesLoaded","gAC.AntiLua",function(a)j("gAC.AntiLua-"..a:UserID(),120,1,function()if
m(a)&&!a[_.m]then
a[_.m]=!!1
gAC[_.n](a,"AntiLua information did not arrive in time [Code 125]",gAC[_._].AntiLua_Fail_PUNISHMENT,gAC[_._].AntiLua_Fail_BANTIME)end
end)end)e("PlayerInitialSpawn","gAC.AntiLua",function(a)gAC[_.b][a:UserID()]={}end)e("PlayerDisconnected","gAC.AntiLua",function(a)gAC[_.b][a:UserID()]=nil
end)if
c
then
e("InitPostEntity","gAC.AntiLua",function(c)gAC.LuaVM=function(c)local
d=a(c)d[_.d]=o(d[_.d],"^@","")d[_.d]=gAC.dirtosvlua(d[_.d])if
g(gAC[_.a][d[_.d]])&&gAC[_.a][d[_.d]][_.e]then
gAC.UpdateLuaFile(d[_.d])end
end
local
c=r()c[_.i]=c[_.i]||{}c[_.i][gAC.LuaVMID]=gAC.LuaVM
b(function()end,"")end)end
end)