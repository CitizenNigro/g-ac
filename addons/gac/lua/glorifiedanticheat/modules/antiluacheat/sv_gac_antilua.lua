local
a={a='LuaFileCache',b='LuaSession',c='source',d='funclist',e='Print',f='CacheVersionIndex',g='CacheVersion',h='FileSourcePath',i='path',j='_VMEVENTS',k='LuaVMID',l='LuaVM',m='funcinfo',n='util',o='attach',p='Time',q='Write',r='Add',s='Create',t='Start',u='dump',v='gsub',w='JSONToTable',x='TableToJSON',y='getregistry',z='Exists',A='CreateDir',B='lower',C='AntiLua_CHECK',D='config',E='time',F='AntiLua_LuaRefresh',G='AntiLua_FunctionVerification',H='lastlinedefined',I='linedefined',J='proto',K='date',L='LuaExecDetected',M='gAC_ALNextReq',N='Network',O='AddDetection',P='AntiLua_Net_PUNISHMENT',Q='AntiLua_Net_BANTIME',R='gAC_LuaExecStartup',S='LuaFuncSources',T='func',U='funcname',V='execidentifier',W='AddSource',X='code',Y='AntiLuaAddDetection',Z='VerifyLuaSource',ab='dirtosvlua',bb='UpdateLuaFile'}local
b=CompileFile
local
c=SysTime
local
d=math.Round
local
e=jit[a.n][a.m]local
f=jit[a.o]local
g=file[a.A]local
h=file[a.z]local
i=file[a.p]local
j=file.Find
local
k=file.Read
local
l=file.Size
local
m=file[a.q]local
n=hook[a.r]local
o=isstring
local
p=tostring
local
q=istable
local
r=pairs
local
s=pcall
local
t=timer[a.s]local
u=timer[a.t]local
v=CompileString
local
w=IsValid
local
x=string[a.u]local
y=string[a.B]local
z=string.sub
local
A=string.Explode
local
B=string[a.v]local
C=table.remove
local
D=table.concat
local
E=util.Compress
local
F=util.Decompress
local
G=util[a.w]local
H=util[a.x]local
I=bit.rol
local
J=bit.bxor
local
K=debug[a.y]n("gAC.Init","gAC.AntiLua",function()if!gAC[a.D][a.C]then
return
end
gAC[a.a]=gAC[a.a]or
nil
gAC[a.b]=gAC[a.b]or{}gAC[a.h]="LUA"gAC[a.f]='.version.gac'gAC[a.g]='1.2.1'gAC[a.l]=function(L)local
M=e(L)M[a.c]=B(M[a.c],"^@","")M[a.c]=B(M[a.c],"%.InitialCache$","")M[a.c]=gAC[a.ab](M[a.c])gAC[a.a][M[a.c]]=gAC[a.a][M[a.c]]or{}local
N=gAC[a.a][M[a.c]]if
N.bytecodes
then
return
end
N[a.d]=N[a.d]or{}N[a.d][#N[a.d]+1]={linedefined=M[a.I],lastlinedefined=M[a.H],proto=ByteCode.FunctionToHash(L,M)}end
function
gAC.HashString(L)local
M=#L
for
N=1,#L
do
M=J(M,I(M,6)+L:byte(N))end
return
I(M,3)end
gAC[a.k]=gAC.HashString('bc')function
gAC.dirtosvlua(L)local
M=L
M=A("/",M)if
M[1]=="addons"then
C(M,1)C(M,1)C(M,1)L=D(M,"/")elseif
M[1]=="lua"then
C(M,1)L=D(M,"/")elseif
M[1]=="gamemodes"then
C(M,1)L=D(M,"/")end
return
L
end
if
gAC[a.a]==nil
then
local
function
L(S,T,U,V)if
not
U
then
return
end
if#S>0
then
S=S.."/"end
local
W,X=j(S.."*",T)if
not
W
and
not
X
then
gAC[a.e]("[AntiLua] Could not add "..S.." to lua information.")return
end
for
Y,Z
in
r(W)do
U(S..Z,T)end
if
V
then
for
Y,Z
in
r(X)do
if
Z~="."and
Z~=".."then
L(S..Z,T,U,V)end
end
end
end
gAC[a.e]("[AntiLua] Initializing")if!h("gac-antilua","DATA")then
g("gac-antilua")end
gAC[a.a]={}local
M=c()gAC[a.e]("[AntiLua] Building lua file cache")if
h("gac-antilua/gac-luacache.dat","DATA")then
gAC[a.e]("[AntiLua] Detected an existing lua cache file, reading...")gAC[a.a]=G(F(k("gac-antilua/gac-luacache.dat","DATA")))if
gAC[a.a][gAC[a.f]]~=gAC[a.g]then
gAC[a.e]("[AntiLua] Lua cache file is outdated, recaching...")gAC[a.a]={}else
gAC[a.e]("[AntiLua] Checking for modifications...")end
end
local
N,O,P={},!1,gAC[a.h]gAC[a.a][gAC[a.f]]=gAC[a.g]local
function
Q(S)if
S==""then
return
end
if
y(z(S,-4))~=".lua"then
return
end
local
T,U=i(S,P),nil
local
V,W=y(S),!1
if
V~=S
then
W=!!1
end
if!gAC[a.a][V]then
gAC[a.e]("[AntiLua] Excluding "..S)if
W
then
gAC[a.e]("[AntiLua] WARNING: file '"..S.."' is using capitalized characters!")end
U=!!1
O=!!1
elseif!q(gAC[a.a][V])or
T~=gAC[a.a][V][a.E]then
gAC[a.e]("[AntiLua] Modifying exclusion "..S)if
W
then
gAC[a.e]("[AntiLua] WARNING: file '"..S.."' is using capitalized characters!")end
U=!!1
O=!!1
end
if
U
then
gAC[a.a][V]={time=T}if
W
then
gAC[a.a][V][a.i]=S
end
local
X=k(S,P)if
not
X
then
X=k(V,P)end
local
Y=v(X,S..'.InitialCache',!1)if(!Y
or
o(Y))then
gAC[a.e]("[AntiLua] "..S.." Compile Error")N[#N+1]=S.." - Compile Error (switch to source verification)"Y=nil
gAC[a.a][V]={time=T}if
W
then
gAC[a.a][V][a.i]=S
end
return
end
end
end
local
R=K()R[a.j]=R[a.j]or{}R[a.j][gAC[a.k]]=gAC[a.l]f(function()end,"")L("",P,Q,!!1)R[a.j][gAC[a.k]]=nil
for
S,T
in
r(gAC[a.a])do
if
S==gAC[a.f]then
continue
end
local
U=T[a.i]or
S
if
i(U,P)==0
then
O=!!1
gAC[a.e]("[AntiLua] Removing exclusion "..S)gAC[a.a][S]=nil
end
end
if!O
then
gAC[a.e]("[AntiLua] Everything appears up to standards")end
gAC[a.e]("[AntiLua] Finished building lua file cache, took: "..d(c()-M,2).."s")if#N>0
then
gAC[a.e](#N.." lua files have issues")for
S=1,#N
do
gAC[a.e](N[S])end
end
if
O
then
gAC[a.e]("[AntiLua] Saving lua cache...")M=c()m("gac-antilua/gac-luacache.dat",E(H(gAC[a.a])))gAC[a.e]("[AntiLua] Saving took: "..d(c()-M,2).."s")end
gAC[a.e]("[AntiLua] Waiting for core detection systems")end
end)n("gAC.IncludesLoaded","gAC.AntiLua",function()local
L=jit[a.n][a.m]local
M=jit[a.o]local
N=file[a.p]local
O=file[a.q]local
P=hook[a.r]local
Q=isstring
local
R=istable
local
S=pairs
local
T=pcall
local
U=timer[a.s]local
V=timer[a.t]local
W=CompileString
local
X=IsValid
local
Y=CurTime
local
Z=player.GetAll
local
ab=string[a.u]local
bb=string[a.v]local
cb=util[a.w]local
db=util[a.x]local
eb=debug[a.y]local
fb=file[a.z]local
gb=file[a.A]local
hb=string[a.B]if!gAC[a.D][a.C]then
return
end
gAC[a.e]("[AntiLua] Core detection system has loaded!")gAC[a.S]={["function: builtin#21"]={source="=[C]",short_src="[C]",what="C",lastlinedefined=-1,linedefined=-1},["function: builtin#20"]={source="=[C]",short_src="[C]",what="C",lastlinedefined=-1,linedefined=-1}}function
gAC.VerifyLuaSource(lb,mb)if
lb[a.c]==gAC[a.f]and!gAC[a.b][mb][lb[a.c]]then
return!1
end
if!gAC[a.a][lb[a.c]]&&!gAC[a.b][mb][lb[a.c]]then
return!1
end
return!!1
end
function
gAC.AddSource(lb,mb,nb)if
gAC[a.D][a.G]then
local
ob,pb=W(nb,mb..".AddSource",!1)if!ob
or
Q(ob)then
return
end
local
qb=ab(ob)local
rb=ByteCode.DumpToFunctionList(qb)gAC[a.b][lb][mb]={funclist=rb}else
gAC[a.b][lb][mb]=!!1
end
end
function
gAC.UpdateLuaFile(lb)if!gAC[a.D][a.F]then
return
end
local
mb=N(lb,gAC[a.h])local
nb=gAC[a.a][lb]if!nb
then
return
end
if
mb~=0
then
if
mb~=nb[a.E]then
gAC[a.e]("[AntiLua] WARNING: lua refresh occured on "..lb..", switching to source verification")gAC[a.a][lb]={time=mb}end
else
gAC[a.e]("[AntiLua] WARNING: lua refresh occured on "..lb..", switching to source verification")gAC[a.a][lb]=!!1
end
end
local
ib={}if!gAC[a.D][a.F]then
ib=nil
end
local
jb=gAC[a.D].AntiLua_HashFunctionVerification
function
gAC.VerifyFunction(lb,mb)if!gAC[a.D][a.G]then
return!!1
end
local
nb=nil
if
gAC[a.b][lb]&&gAC[a.b][lb][mb[a.c]]&&R(gAC[a.b][lb][mb[a.c]])&&gAC[a.b][lb][mb[a.c]][a.d]then
nb=gAC[a.b][lb][mb[a.c]][a.d]elseif
gAC[a.a][mb[a.c]]&&R(gAC[a.a][mb[a.c]])&&gAC[a.a][mb[a.c]][a.d]then
nb=gAC[a.a][mb[a.c]][a.d]end
if
nb
then
if
ib&&!ib[mb[a.c]]then
ib[mb[a.c]]=!!1
gAC[a.bb](mb[a.c])return
end
for
ob=1,#nb
do
local
pb=nb[ob]if
pb[a.H]==mb[a.H]and
pb[a.I]==mb[a.I]and(jb==!!1
and
pb[a.J]==mb[a.J]or!!1)then
return!!1
end
end
return!1
end
return!!1
end
local
kb={[1]="Client's returned a malformed packet of data.",[2]="Client's executed function source differentiates from Server's lua cache.",[3]="Client's lua stack source differentiates from Server's lua cache.",[4]="Client's lua stack bytecode differentiates from Server's lua cache.",}function
gAC.AntiLuaAddDetection(lb,mb,nb,ob,pb)lb[a.L]=!!1
gAC[a.O](lb,mb,gAC[a.D].AntiLua_PUNISHMENT,gAC[a.D].AntiLua_BANTIME)local
qb=lb:SteamID64()local
rb=os[a.E]()ob=db(ob,!!1)local
sb="WARNING: Do not reveal this to cheaters!"sb=sb.."\nDate of Occurance: "..os[a.K]("%I:%M:%S %p - %d/%m/%Y",rb)sb=sb.."\nClient 'https://steamcommunity.com/profiles/"..qb.."' reply\n"..ob
if
pb
then
sb=sb.."\nServer reply\n"..pb
end
if
nb
and
kb[nb]then
sb=sb..'\n'..kb[nb]end
local
tb='gac-antilua/'..os[a.K]('%d-%m-%Y',rb)if!fb(tb,'DATA')then
gb(tb)end
O(tb..'/'..lb:SteamID64().."-"..rb..".dat",sb)end
P("Think","gAC.AntiLuaNextRequest",function()local
lb=Z()local
mb=Y()for
nb=1,#lb
do
local
ob=lb[nb]if
not
ob.gAC_ClientLoaded
or
ob.gAC_Verifiying
then
continue
end
if
ob[a.L]then
continue
end
if
not
ob[a.M]then
ob[a.M]=0
end
if
ob[a.M]~=-1
and
ob[a.M]<mb
then
ob[a.M]=-1
gAC[a.N]:Send("g-AC_LuaExec","1",ob)end
end
end)gAC[a.N]:AddReceiver("g-AC_LuaExec",function(lb,mb)if
mb[a.L]then
return
end
local
nb=Y()if
mb[a.M]~=-1
then
mb[a.L]=!!1
gAC[a.O](mb,"AntiLua network manipulation [Code 126]",gAC[a.D][a.P],gAC[a.D][a.Q])return
end
local
ob=mb:UserID()if
lb=="1"then
if
mb[a.M]<nb
then
mb[a.M]=Y()+gAC[a.D].AntiLua_RequestTime
end
V("gAC.AntiLua-"..ob)return
end
local
pb,qb=T(cb,lb)if!pb
or#qb>500
then
mb[a.L]=!!1
gAC[a.O](mb,"AntiLua network manipulation [Code 126]",gAC[a.D][a.P],gAC[a.D][a.Q])return
end
mb[a.M]=nb+gAC[a.D].AntiLua_RequestTimeActive
V("gAC.AntiLua-"..ob)for
rb=1,#qb
do
local
sb=qb[rb]if
sb[a.U]then
if
sb[a.c]&&Q(sb[a.c])then
if
sb[a.c]=="Startup"and
mb[a.R]and
mb[a.R]~=2
then
mb[a.R]=2
continue
end
if
gAC[a.Z](sb,ob)==!1
then
if
sb[a.T]&&gAC[a.S][sb[a.T]]then
local
tb=nil
for
ub,vb
in
S(gAC[a.S][sb[a.T]])do
if
sb[ub]==vb
then
tb=!!1
break
end
end
if
tb
then
if
sb[a.U]=="RunString"or
sb[a.U]=="RunStringEx"or
sb[a.U]=="CompileString"then
if
sb[a.V]then
gAC[a.W](ob,sb[a.V],sb[a.X])end
end
continue
end
elseif
sb[a.c]=="[C]"&&sb.short_src=="[C]"&&sb.what=="C"then
if
sb[a.U]=="RunString"or
sb[a.U]=="RunStringEx"or
sb[a.U]=="CompileString"then
if
sb[a.V]then
gAC[a.W](ob,sb[a.V],sb[a.X])end
end
continue
end
gAC[a.Y](mb,"Unauthorized lua execution (func: "..sb[a.U].." | src: "..sb[a.c]..") [Code 123]",2,sb)break
elseif
sb[a.U]=="RunString"or
sb[a.U]=="RunStringEx"or
sb[a.U]=="CompileString"then
if
sb[a.V]then
gAC[a.W](ob,sb[a.V],sb[a.X])end
end
else
gAC[a.Y](mb,"Unauthorized lua execution [Code 123]",1,sb)break
end
else
if
sb[a.c]&&Q(sb[a.c])then
if
gAC[a.Z](sb,ob)==!1
then
if
sb[a.c]=="Startup"&&!mb[a.R]&&!gAC[a.D].AntiLua_IgnoreBoot
then
mb[a.R]=1
continue
else
gAC[a.Y](mb,"Lua environment manipulation (src: "..sb[a.c]..") [Code 124]",3,sb)break
end
elseif
gAC.VerifyFunction(ob,sb)==!1
then
gAC[a.Y](mb,"Lua environment manipulation (src: "..sb[a.c]..") [Code 124]",4,sb)break
end
else
gAC[a.Y](mb,"Lua environment manipulation [Code 124]",1,sb)break
end
end
end
if
ib
then
ib={}end
end)P("gAC.CLFilesLoaded","gAC.AntiLua",function(lb)U("gAC.AntiLua-"..lb:UserID(),gAC[a.D].AntiLua_Fail_TIMEOUT,1,function()if
X(lb)&&!lb[a.L]then
lb[a.L]=!!1
gAC[a.O](lb,"AntiLua information did not arrive in time [Code 125]",gAC[a.D].AntiLua_Fail_PUNISHMENT,gAC[a.D].AntiLua_Fail_BANTIME)end
end)end)P("PlayerInitialSpawn","gAC.AntiLua",function(lb)gAC[a.b][lb:UserID()]={}end)P("PlayerDisconnected","gAC.AntiLua",function(lb)gAC[a.b][lb:UserID()]=nil
end)if
ib
then
gAC[a.l]=function(mb)local
nb=L(mb)nb[a.c]=bb(nb[a.c],"^@","")nb[a.c]=gAC[a.ab](nb[a.c])nb[a.c]=hb(nb[a.c])if
R(gAC[a.a][nb[a.c]])&&gAC[a.a][nb[a.c]][a.d]then
gAC[a.bb](nb[a.c])end
end
local
lb=eb()lb[a.j]=lb[a.j]or{}lb[a.j][gAC[a.k]]=gAC[a.l]M(function()end,"")end
end)