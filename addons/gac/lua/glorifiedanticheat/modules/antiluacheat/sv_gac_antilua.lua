local a = {a='LuaFileCache',b='LuaSession',c='source',d='funclist',e='Print',f='FileSourcePath',g='_VMEVENTS',h='LuaVMID',i='LuaVM',j='NoLuaCache',k='funcinfo',l='util',m='attach',n='Time',o='Write',p='Add',q='Create',r='Start',s='dump',t='gsub',u='JSONToTable',v='TableToJSON',w='getregistry',x='AntiLua_CHECK',y='config',z='time',A='AntiLua_LuaRefresh',B='AntiLua_FunctionVerification',C='lastlinedefined',D='linedefined',E='proto',F='AddDetection',G='LuaExecDetected',H='AntiLua_Net_PUNISHMENT',I='AntiLua_Net_BANTIME',J='LuaFuncSources',K='func',L='funcname',M='execidentifier',N='AddSource',O='code',P='AntiLuaAddDetection',Q='VerifyLuaSource',R='gAC_LuaExecStartup',S='dirtosvlua',T='UpdateLuaFile'}local
b=CompileFile
local
c=SysTime
local
d=math.Round
local
e=jit[a.l][a.k]local
f=jit[a.m]local
g=file.CreateDir
local
h=file.Exists
local
i=file[a.n]local
j=file.Find
local
k=file.Read
local
l=file.Size
local
m=file[a.o]local
n=hook[a.p]local
o=isstring
local
p=tostring
local
q=istable
local
r=pairs
local
s=pcall
local
t=timer[a.q]local
u=timer[a.r]local
v=CompileString
local
w=IsValid
local
x=string[a.s]local
y=string.lower
local
z=string.sub
local
A=string.Explode
local
B=string[a.t]local
C=table.remove
local
D=table.concat
local
E=util.Compress
local
F=util.Decompress
local
G=util[a.u]local
H=util[a.v]local
I=bit.rol
local
J=bit.bxor
local
K=debug[a.w]n("gAC.Init","gAC.AntiLua",function()if!gAC[a.y][a.x]then
return
end
gAC[a.a]=gAC[a.a]or
nil
gAC[a.b]=gAC[a.b]or{}gAC[a.f]="LUA"gAC[a.i]=function(L)local
M=e(L)M[a.c]=B(M[a.c],"^@","")M[a.c]=gAC[a.S](M[a.c])gAC[a.a][M[a.c]]=gAC[a.a][M[a.c]]or{}local
N=gAC[a.a][M[a.c]]if
N.bytecodes
then
return
end
N[a.d]=N[a.d]or{}N[a.d][#N[a.d]+1]={linedefined=M[a.D],lastlinedefined=M[a.C],proto=ByteCode.FunctionToHash(L,M)}end
function
gAC.HashString(L)local
M=#L
for
N=1,#L
do
M=J(M,I(M,6)+L:byte(N))end
return
I(M,3)end
gAC[a.h]=gAC.HashString('bc')function
gAC.dirtosvlua(L)local
M=L
M=A("/",M)if
M[1]=="addons"then
C(M,1)C(M,1)C(M,1)L=D(M,"/")elseif
M[1]=="lua"then
C(M,1)L=D(M,"/")elseif
M[1]=="gamemodes"then
C(M,1)L=D(M,"/")end
return
L
end
if
gAC[a.a]==nil
then
local
function
L(S,T,U,V)if
not
U
then
return
end
if#S>0
then
S=S.."/"end
local
W,X=j(S.."*",T)if
not
W
and
not
X
then
gAC[a.e]("[AntiLua] Could not add "..S.." to lua information.")return
end
for
Y,Z
in
r(W)do
U(S..Z,T)end
if
V
then
for
Y,Z
in
r(X)do
if
Z~="."and
Z~=".."then
L(S..Z,T,U,V)end
end
end
end
gAC[a.e]("[AntiLua] Initializing")if!h("gac-antilua","DATA")then
g("gac-antilua")end
gAC[a.a]={}local
M=c()gAC[a.e]("[AntiLua] Building lua file cache")if
h("gac-antilua/gac-luacache.dat","DATA")then
gAC[a.e]("[AntiLua] Detected an existing lua cache file, reading...")gAC[a.a]=G(F(k("gac-antilua/gac-luacache.dat","DATA")))gAC[a.e]("[AntiLua] Checking for modifications...")else
gAC[a.j]=true
end
local
N,O,P={},false,gAC[a.f]local
function
Q(S)if
y(z(S,-4))~=".lua"then
return
end
if
S==""then
return
end
local
T,U=i(S,P),nil
if!gAC[a.a][S]then
gAC[a.e]("[AntiLua] Excluding "..S)U=true
O=true
elseif!q(gAC[a.a][S])or
T~=gAC[a.a][S][a.z]then
gAC[a.e]("[AntiLua] Modifying exclusion "..S)U=true
O=true
end
if
U
then
gAC[a.a][S]={time=T}local
V=b(S)if!V
and
y(S)~=S
then
gAC[a.a][S]={time=T}V=b(y(S))end
if!V
then
gAC[a.e]("[AntiLua] "..S.." Compile Error")N[#N+1]=S.." - Compile Error (switch to source verification)"V=nil
gAC[a.a][S]={time=T}return
end
end
end
local
R=K()R[a.g]=R[a.g]or{}R[a.g][gAC[a.h]]=gAC[a.i]f(function()end,"")L("",P,Q,true)R[a.g][gAC[a.h]]=nil
for
S,T
in
r(gAC[a.a])do
if
i(S,P)==0
then
O=true
gAC[a.e]("[AntiLua] Removing exclusion "..S)gAC[a.a][S]=nil
end
end
if!O
then
gAC[a.e]("[AntiLua] Everything appears up to standards")end
gAC[a.e]("[AntiLua] Finished building lua file cache, took: "..d(c()-M,2).."s")if#N>0
then
gAC[a.e](#N.." lua files have issues")for
S=1,#N
do
gAC[a.e](N[S])end
end
if
O
then
gAC[a.e]("[AntiLua] Saving lua cache...")if
gAC[a.j]then
gAC[a.e]("[AntiLua] Server will restart on InitPostEntity (needed to remove compiled files in lua)")n("InitPostEntity","gAC.AntiLua.Restart",function(S)gAC[a.e]("[AntiLua] Restarting...")RunConsoleCommand('_restart')end)end
M=c()m("gac-antilua/gac-luacache.dat",E(H(gAC[a.a])))gAC[a.e]("[AntiLua] Saving took: "..d(c()-M,2).."s")end
gAC[a.e]("[AntiLua] Waiting for core detection systems")end
end)n("gAC.IncludesLoaded","gAC.AntiLua",function()local
L=jit[a.l][a.k]local
M=jit[a.m]local
N=file[a.n]local
O=file[a.o]local
P=hook[a.p]local
Q=isstring
local
R=istable
local
S=pairs
local
T=pcall
local
U=timer[a.q]local
V=timer[a.r]local
W=CompileString
local
X=IsValid
local
Y=string[a.s]local
Z=string[a.t]local
ab=util[a.u]local
bb=util[a.v]local
cb=debug[a.w]if!gAC[a.y][a.x]then
return
end
gAC[a.e]("[AntiLua] Core detection system has loaded!")gAC[a.J]={["function: builtin#21"]={source="=[C]",short_src="[C]",what="C",lastlinedefined=-1,linedefined=-1},["function: builtin#20"]={source="=[C]",short_src="[C]",what="C",lastlinedefined=-1,linedefined=-1}}function
gAC.VerifyLuaSource(eb,fb)if!gAC[a.a][eb[a.c]]&&!gAC[a.b][fb][eb[a.c]]then
return
false
end
return
true
end
function
gAC.AddSource(eb,fb,gb)if
gAC[a.y][a.B]then
local
hb,ib=W(gb,fb..".AddSource",false)if!hb&&ib
then
return
end
local
jb=Y(hb)local
kb=ByteCode.DumpToFunctionList(jb)gAC[a.b][eb][fb]={funclist=kb}else
gAC[a.b][eb][fb]=true
end
end
function
gAC.UpdateLuaFile(eb)if!gAC[a.y][a.A]then
return
end
local
fb=N(eb,gAC[a.f])if
fb~=0
then
if
fb~=gAC[a.a][eb][a.z]then
gAC[a.e]("[AntiLua] WARNING: lua refresh occured on "..eb..", switching to source verification")gAC[a.a][eb]={time=fb}end
else
gAC[a.e]("[AntiLua] WARNING: lua refresh occured on "..eb..", switching to source verification")gAC[a.a][eb]=true
end
end
local
db={}if!gAC[a.y][a.A]then
db=nil
end
function
gAC.VerifyFunction(eb,fb)if!gAC[a.y][a.B]then
return
true
end
local
gb=nil
if
gAC[a.b][eb]&&gAC[a.b][eb][fb[a.c]]&&R(gAC[a.b][eb][fb[a.c]])&&gAC[a.b][eb][fb[a.c]][a.d]then
gb=gAC[a.b][eb][fb[a.c]][a.d]elseif
gAC[a.a][fb[a.c]]&&R(gAC[a.a][fb[a.c]])&&gAC[a.a][fb[a.c]][a.d]then
gb=gAC[a.a][fb[a.c]][a.d]end
if
gb
then
if
db&&!db[fb[a.c]]then
db[fb[a.c]]=true
gAC[a.T](fb[a.c])return
end
for
hb=1,#gb
do
local
ib=gb[hb]if
ib[a.C]~=fb[a.C]then
return
false
end
if
ib[a.D]~=fb[a.D]then
return
false
end
if
ib[a.E]~=fb[a.E]then
return
false
end
end
return
true
end
return
true
end
function
gAC.AntiLuaAddDetection(eb,fb,gb,hb)if
gb~="Probable Execution"then
hb[a.G]=true
gAC[a.F](hb,fb,gAC[a.y].AntiLua_PUNISHMENT,gAC[a.y].AntiLua_BANTIME)else
gAC[a.F](hb,fb,false,-1)end
local
ib=bb(eb,true)ib="WARNING: Do not reveal this to cheaters!\nClient "..hb:SteamID64().."'s reply\n"..ib
ib=ib.."\nServer's reply\n"..fb.."\n"if
gb=="%unknown%"then
gb="Client returned a traceback with nil or unknown type (likely a client detour attempt)"elseif
gb=="Invalid Source"then
gb="Client returned a traceback leading to '"..eb[a.c].."' which does not exist in the lua cache"elseif
gb=="Invalid Bytecode"then
gb="Client returned a traceback leading to '"..eb[a.c].."' which exists on the lua cache\n"gb=gb.."however the function information returned to it is different from the lua cache"elseif
gb=="Probable Execution"then
gb="Client returned a traceback leading to '"..eb[a.c].."' which does not exist in the lua cache\n"gb=gb.."however because of the given environment information, it's unable to be confirmed."end
ib=ib..gb
O("gac-antilua/"..hb:SteamID64().."-"..os[a.z]()..".dat",ib)end
gAC.Network:AddReceiver("g-AC_LuaExec",function(eb,fb,gb)if
gb[a.G]then
return
end
local
hb=gb:UserID()if
fb=="1"then
V("gAC.AntiLua-"..hb)return
end
local
ib,jb=T(ab,fb)if!ib
then
gb[a.G]=true
gAC[a.F](gb,"AntiLua network manipulation [Code 126]",gAC[a.y][a.H],gAC[a.y][a.I])return
end
V("gAC.AntiLua-"..hb)if#jb>500
then
gb[a.G]=true
gAC[a.F](gb,"AntiLua network manipulation [Code 126]",gAC[a.y][a.H],gAC[a.y][a.I])return
end
for
kb=1,#jb
do
local
lb=jb[kb]if
lb[a.L]then
if
lb[a.c]&&Q(lb[a.c])then
if
gAC[a.Q](lb,hb)==false
then
if
lb[a.K]&&gAC[a.J][lb[a.K]]then
local
mb=nil
for
nb,ob
in
S(gAC[a.J][lb[a.K]])do
if
lb[nb]==ob
then
mb=true
break
end
end
if
mb
then
if
lb[a.L]=="RunString"or
lb[a.L]=="RunStringEx"or
lb[a.L]=="CompileString"then
if
lb[a.M]then
gAC[a.N](hb,lb[a.M],lb[a.O])end
end
continue
end
elseif
lb[a.c]=="[C]"&&lb.short_src=="[C]"&&lb.what=="C"then
if
lb[a.L]=="RunString"or
lb[a.L]=="RunStringEx"or
lb[a.L]=="CompileString"then
if
lb[a.M]then
gAC[a.N](hb,lb[a.M],lb[a.O])end
end
continue
end
gAC[a.P](lb,"Unauthorized lua execution (func: "..lb[a.L].." | src: "..lb[a.c]..") [Code 123]","Invalid Source",gb)break
elseif
lb[a.L]=="RunString"or
lb[a.L]=="RunStringEx"or
lb[a.L]=="CompileString"then
if
lb[a.M]then
gAC[a.N](hb,lb[a.M],lb[a.O])end
end
else
gAC[a.P](lb,"Unauthorized lua execution [Code 123]","%unknown%",gb)break
end
else
if
lb[a.c]&&Q(lb[a.c])then
if
gAC[a.Q](lb,hb)==false
then
if
lb[a.c]=="Startup"&&!gb[a.R]&&!gAC[a.y].AntiLua_IgnoreBoot
then
gb[a.R]=true
continue
else
gAC[a.P](lb,"Lua environment manipulation (src: "..lb[a.c]..") [Code 124]","Invalid Source",gb)break
end
elseif
gAC.VerifyFunction(lb,gb)==false
then
gAC[a.P](lb,"Lua environment manipulation (src: "..lb[a.c]..") [Code 124]","Invalid Bytecode",gb)break
end
else
gAC[a.P](lb,"Lua environment manipulation [Code 124]","%unknown%",gb)break
end
end
end
if
db
then
db={}end
end)P("gAC.CLFilesLoaded","gAC.AntiLua",function(eb)U("gAC.AntiLua-"..eb:UserID(),120,1,function()if
X(eb)&&!eb[a.G]then
eb[a.G]=true
gAC[a.F](eb,"AntiLua information did not arrive in time [Code 125]",gAC[a.y].AntiLua_Fail_PUNISHMENT,gAC[a.y].AntiLua_Fail_BANTIME)end
end)end)P("PlayerInitialSpawn","gAC.AntiLua",function(eb)gAC[a.b][eb:UserID()]={}end)P("PlayerDisconnected","gAC.AntiLua",function(eb)gAC[a.b][eb:UserID()]=nil
end)if
db
then
gAC[a.i]=function(fb)local
gb=L(fb)gb[a.c]=Z(gb[a.c],"^@","")gb[a.c]=gAC[a.S](gb[a.c])if
R(gAC[a.a][gb[a.c]])&&gAC[a.a][gb[a.c]][a.d]then
gAC[a.T](gb[a.c])end
end
local
eb=cb()eb[a.g]=eb[a.g]or{}eb[a.g][gAC[a.h]]=gAC[a.i]M(function()end,"")end
end)